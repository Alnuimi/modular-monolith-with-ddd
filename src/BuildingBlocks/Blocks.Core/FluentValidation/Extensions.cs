using Blocks.Core.Extensions;
using FluentValidation;

namespace Blocks.Core.FluentValidation;

public static class Extensions
{
    public static IRuleBuilderOptions<T, TProperty> WithMessageForInvalidId<T, TProperty>(
        this IRuleBuilderOptions<T, TProperty> ruleBuilder, string propertyName)
        => ruleBuilder.WithMessage(c => ValidationMessages.InvalidId.FormatWith(propertyName));
    
    public static IRuleBuilderOptions<T, TProperty> NotEmptyWithMessage<T, TProperty>(
        this IRuleBuilder<T, TProperty> ruleBuilder, string propertyName)
        => ruleBuilder
            .NotEmpty()
            .WithMessage(c => ValidationMessages.NullOrEmptyValue.FormatWith(propertyName));

    public static IRuleBuilderOptions<T, string?> MaximumLengthWithMessage<T>(
        this IRuleBuilder<T, string?> ruleBuilder, int maxLength, string propertyName)
        => ruleBuilder
            .MaximumLength(maxLength)
            .WithMessage(c => ValidationMessages.MaxLengthExceeded.FormatWith(propertyName));
    
    public static IRuleBuilderOptions<T, TProperty> NotNullWithMessage<T, TProperty>(
        this IRuleBuilder<T, TProperty> ruleBuilder, string propertyName)
        => ruleBuilder
            .NotNull()
            .WithMessage(c => ValidationMessages.NullOrEmptyValue.FormatWith(propertyName));
}